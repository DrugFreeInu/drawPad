<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>DrawPad</title>

<style>
html, body {
  margin: 0;
  height: 100%;
  overflow: hidden;
  background: #0b0b0b;
}

canvas {
  display: block;
  touch-action: none;
  cursor: crosshair;
}

#controls {
  position: fixed;
  bottom: 18px;
  left: 18px;
  display: flex;
  gap: 10px;
  z-index: 10;
}

.btn {
  padding: 12px 16px;
  border-radius: 22px;
  background: rgba(18,30,60,0.4);
  color: #8fbfff;
  font-weight: 600;
  user-select: none;
  backdrop-filter: blur(6px);
}

.btn.hold.active {
  background: rgba(120,170,255,0.35);
  color: #fff;
}
</style>
</head>
<body>

<canvas id="draw"></canvas>

<div id="controls">
  <div class="btn hold" id="boldHold">Hold</div>
  <div class="btn" id="clearBtn">Clear</div>
</div>

<script>
const canvas = document.getElementById('draw');
const ctx = canvas.getContext('2d');

let drawing = false;
let path = [];
let points = [];

let boldActive = false;
let boldStart = 0;
const MAX_BOLD_TIME = 3000;

/* Resize */
function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
addEventListener('resize', resize);
resize();

ctx.lineCap = 'round';
ctx.lineJoin = 'round';

/* Input */
function start(x, y) {
  drawing = true;
  path = [{ x, y }];
  points.push({ x, y });
}

function move(x, y) {
  if (!drawing) return;
  path.push({ x, y });
  points.push({ x, y });
  redraw();
}

function end() {
  drawing = false;
  path = [];
}

/* Chalk stroke with micro dust breakup */
function redraw() {
  if (path.length < 2) return;

  let t = 0;
  if (boldActive) {
    t = Math.min((performance.now() - boldStart) / MAX_BOLD_TIME, 1);
  }

  const baseAlpha = 0.06 + t * 0.28;
  const width = 22 + t * 26;

  ctx.lineWidth = width;

  ctx.beginPath();
  ctx.moveTo(path[0].x, path[0].y);

  for (let i = 1; i < path.length; i++) {
    const p = path[i];
    const prev = path[i - 1];

    // ---- MICRO IMPERFECTION ----
    // tiny dropout chance per segment
    if (Math.random() < 0.06) {
      ctx.strokeStyle = `rgba(210,225,255,${baseAlpha * 0.35})`;
    } else {
      // subtle alpha fluctuation
      const jitterAlpha =
        baseAlpha * (0.85 + Math.random() * 0.3);
      ctx.strokeStyle = `rgba(210,225,255,${jitterAlpha})`;
    }

    // micro position wobble (chalk crumble)
    const wobble = 0.6 + Math.random() * 0.8;

    ctx.lineTo(
      p.x + (Math.random() - 0.5) * wobble,
      p.y + (Math.random() - 0.5) * wobble
    );
  }

  ctx.stroke();
}

/* Mouse */
canvas.addEventListener('mousedown', e => start(e.clientX, e.clientY));
canvas.addEventListener('mousemove', e => move(e.clientX, e.clientY));
canvas.addEventListener('mouseup', end);
canvas.addEventListener('mouseleave', end);

/* Touch */
canvas.addEventListener('touchstart', e => {
  const t = e.touches[0];
  start(t.clientX, t.clientY);
});
canvas.addEventListener('touchmove', e => {
  const t = e.touches[0];
  move(t.clientX, t.clientY);
});
canvas.addEventListener('touchend', end);

/* Hold-to-bold */
const holdBtn = document.getElementById('boldHold');

function activateBold() {
  if (!boldActive) {
    boldActive = true;
    boldStart = performance.now();
    holdBtn.classList.add('active');
  }
}

function deactivateBold() {
  boldActive = false;
  holdBtn.classList.remove('active');
}

holdBtn.addEventListener('mousedown', activateBold);
holdBtn.addEventListener('mouseup', deactivateBold);
holdBtn.addEventListener('mouseleave', deactivateBold);
holdBtn.addEventListener('touchstart', e => { e.preventDefault(); activateBold(); });
holdBtn.addEventListener('touchend', e => { e.preventDefault(); deactivateBold(); });

/* Clear */
document.getElementById('clearBtn').onclick = () => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  points = [];
};

/* Export */
window.addEventListener('message', e => {
  if (e.data?.type === 'getPoints') {
    parent.postMessage({ type: 'sendPoints', points }, '*');
  }
});
</script>

</body>
</html>
